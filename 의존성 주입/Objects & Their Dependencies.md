# Objects & Their Dependencies

[Advanced iOS App Architecture, Chapter 4: Objects & Their Dependencies](https://www.raywenderlich.com/books/advanced-ios-app-architecture/v3.0/chapters/4-objects-their-dependencies#toc-chapter-007-anchor-015)

> 이번챕터는 객체들과 의존성들에 대한 내용이면서, 객체를 다른 객체에게 어떻게 제공할지에 대한 것을 다룬다. 이로서 유닛테스트에 대해서 더 통제를 가져갈 수 있으며 객체 지향 시스템을 디자인할 수 있게된다.
> 

객체를 더 작은 단위로 쪼개고, 그들을 다시 합치는 것 방법에 대한 디자인은 아키택처 기술의 기반이 된다. 이 챕터에서는 객체 의존성을 관리하는 것에 대한 장점을 배울 것이다. 그리고 주로 쓰이는 의존성 패턴에 대해 공부한다. 그리고 마지막에는 의존성 주입에 대한 deep dive를 할 것이다. 딥 다이브 전에 객체 의존성 관리를 하는 목표를 알아야한다. 이를 통해서 이 챕터에서 다루려는 것을 이해할 수 있다.

## Establishing the Goals

- Maintainability : 결함을 일으키지 않으면서 코드를 변경할 수 있는 능력
- Testability
- Substituability: 컴파일시 그리고 런타임시 의존성에 대한 구현을 교체할 수 있는 능력. 이 능력은 A/B 테스트 할 때 유용하다.
- Deferability: DB기술 선택과 같은 중대한 결정을 연기할 수 있는 능력이 있다.
- Parallel work streams
- Minimizing object lifetimes
- Reusability: 여러 기능과 여러 앱에서 쉽게 재사용할 수 있는 구성요소로 코드 기반을 구축한다.

## 용어

**의존성**은 특정한 일을 하기 위해서 다른 객체에 의존하고 있는 객체를 말한다.

<img width="543" alt="스크린샷_2022-01-24_오전_12 45 33" src="https://user-images.githubusercontent.com/69891604/151143069-972a184f-6cc5-4a41-a657-7f94082050b1.png">


의존성은 또한 다른 객체들에도 의존할 수도 있다. 그 다른 객체들을 **전이적 의존성(Transitive dependency)**이라고 한다.

<img width="578" alt="스크린샷_2022-01-24_오전_12 47 07" src="https://user-images.githubusercontent.com/69891604/151143086-e9ede79a-1937-430f-9923-b891ea31b502.png">

**Object-under-construction은 의존성에 의존하는 객체이다.**

<img width="483" alt="스크린샷_2022-01-24_오전_12 48 49" src="https://user-images.githubusercontent.com/69891604/151143115-71055fa7-a15b-43f1-8f21-dd297168891c.png">

객체가 생성자 아래로 가는 이유는 **Consumer** 라는 다른 객체에 의해서 쓰여야하기 때문이다.

<img width="446" alt="스크린샷_2022-01-24_오전_12 51 28" src="https://user-images.githubusercontent.com/69891604/151143164-15c00453-8e60-45a6-9fae-c7fd9b0c6a0a.png">

**Transitive dependency**에 의존하는 의존성에 의존하는 객체를 필요로 하는 소비자가 있고, 이것이 계속 이어져 나가는 것이 결국은 **객체** **그래프(object graph)**이다.

<img width="488" alt="스크린샷_2022-01-24_오전_12 53 12" src="https://user-images.githubusercontent.com/69891604/151143210-eb47ee5b-d853-4a52-990b-25b74ea43ca5.png">

이 챕터에서는 의존성 패턴의 안과 밖을 모두 본다고 한다. 밖은 장기 밖에 있는 코드를 살펴볼 것이고, 안은 **object-under-contruction** 안에 있는 코드를 살펴볼 것이다. 

## 의존성 만들기(Creating dependencies)

### Refactoring massive classes

좋은 객체지향형 디자인에서 클래스들은 작고 적은 책임을 가져야한다. 작은 클래스로 나누면서 원래의 큰 클래스는 작은 클래스들의 인스턴스에 의존한다.

### Removing duplicate code

네트워킹 코드를 다른 클래스로 나눠서 뷰컨트롤러가 네트워킹 클래스를 의존할수 있도록 한다.

### Controlling side effects

작은 클래스들의 부작용을 막기 위해서 의존성 패턴을 사용할 수 있다.

## 근본적인 고려사항 (The fundamental considerations)

서로에 대해서 의존하는 관계인 객체를 디자인할때, 어떻게 object-under-contruction이 그 의존성에 액세스 할 수 있을지를 고민해야한다. 또한 그 의존성의 구현을 어떻게 변경할 수 있을지를 고려해야한다.

### 의존성에 접근하기(Accessing Dependencies)

object-under-construction은 그의 의존성에 대해서 접근을 해서 의존성에 정의되어있는 메서드를 사용할 수 있어야한다. 여기서 object-under-construction 객체가 의존성을 가지고 있는 방법을 이야기한다.

**내부에서**

- **전역변수**: object-under-construction은 전역 변수에 간단히 접근가능하다.
- **객체화**: 만약에 의존성이 object-under-construction 보다 더 길게 살지 않아도 된다면, object-under-construction 객체는 의존성을 객체화시켜도 된다.

**외부에서**

- **생성자 인자** : 의존성은 생성자의 인자로 제공받을 수 있다.
- **변경가능한 저장 프로퍼티** : 의존성은 이미 만들어 놓은 저장 프로퍼티를 변경하면서 제공될 수 있다.
- **메서드 :** 의존성들은 object-under-construction의 메소드를 통해서 제공받을 수 있다

### 대체가능성 결정하기(Determining substitutability)

모든 의존성들이 대체가능성을 구현할 필요는 없다. 부작용이 없는 의존성(pure business logic)의 구현을 대체할 필요는 없는 것이다. 하지만 만약 의존성이 디스크에 저장하고, 네트워크 콜을 하고, 분석 이벤트를 보내고, 다른 스크린으로 네비게이션한다면, 아마 의존성의 구현을 개발할때 혹은 테스트할 때 대체해야할 수도 있다.

### 대체 가능성 디자인하기(Designing substitutability)

만약 대체를 해야하는 의존성이 있다면, 의존성 구현을 컴파일 시에 변경할지, 런타임에 변경할지, 아니면 둘다 할지를 정해야한다. AB테스트를 위한 것이라면 런타임에 의존성 구현을 변경할 필요가 있을 것이다. 하지만 일반적인 테스트시에는 컴파일 시의 대체 가능성에 개발자들은 의지한다.

## 의존성 패턴 (Dependency patterns)

의존성 주입과 Service-locator 패턴은 가장 많이 쓰이는 패턴들이다.

- Dependency Injection(의존성 주입): 기본적인 아이디어는 모든 의존성들을 object-under-construction 밖에서 주입하는 것이다.
- Service Locator: 서비스 로케이터는 의존성을 만들고 의존성을 유지할 수 있는 객체이다. object-under-construction을 서비스 로케이터와 함께 제공한다. object-under-construction이 의존성이 필요할때마다, 서비스 로케이터에게 의존성을 만들거나, 제공해달라고 물어보면 된다. 이 패턴은 의존성 주입 패턴보다는 편하게 사용할 수 있다. 하지만 자동화 테스트를 사용할때 더 많은 작업을 요한다.

다른방법으로 의존성을 주입하는 방법이 있다.

- Environment: 환경은 변경 가능한 구조체로 모든 의존성을 object under construction에 제공한다. 서비스 로케이터와 비슷하다. 하지만 다른점은 서비스 로케이터와는 달리 object under construction 내부에서 의존성을 주입한다.
- Protocol Extension: 프로토콜의 익스텐션을 사용하면서 object-under-construction이 의존성에 접근할 수 있도록 하는것이다.

## 의존성 주입(Dependency Injection)

의존성 주입의 주요 목표는 구성 중인 객체 내에서 의존성을 쿼리하는 것과는 반대로 구성중인 객체 외부에서 의존성을 제공하는 것이다. 결국 의존성들은 ‘주입’된다.

의존성을 외부화시키는 것은 의존성을 제어할 수 있게 만든다 특히나 테스트에서. 예를 들어서 의존성을 외부화시키면서, 어떤 의존성을 객체가 가지는 지 객체의 공개 api를 확인하면서 알수 있다.

### 주입의 종류

- **Initiallizer(생성자)** : 소비자는 의존성을 구성중인 객체에 구성중인 객체가 인스턴스화 될때 해주기 위해서 이니셜라이저에 넣어준다. 생성자의 인자로 의존성을 추가해주면 된다. 이 방법이 가장 최고의 주입 방법이라고 할 수 있다. 왜냐하면 의존성을 변경 불가능한 저장 프로퍼티에 저장할 수 있기 때문이다. 구성중인 객체는 의존성이 Nil일 경우를 생각하지 않아도 되고, 또한 의존성이 변경될 일을 생각하지 않아도 된다.
- **Property(프로퍼티)** : 구성중인 객체가 객체화된 뒤에, 소비자는 저장 프로퍼티에 의존성을 세팅하면서 의존성을 주입할 수 있다. 만약에 초기값이 없다면, 의존성 변수를 옵서널로 만들어야한다. 이 의존성 타입은 인터페이스 빌더로 만든 뷰컨트롤러에서 많이 쓰인다. 왜냐면 인터페이스 빌더로 만든다면 생성자 제어가 어렵기때문이다.
- **Method(메서드)** : 구성중인 객체 내에 있는 메서드를 부르면서 의존성을 주입하는 방법도 있다. 거의 쓰이지 않는다. 하지만 특정 의존성이 특정 메소드 내에서만 사용된다면, 이럴 경우 메소드 의존성을 사용해되 괜찮다. 이럴 경우 구성중인 객체가 의존성을 가지고 있지 않아도 된다는 장점이 있다.

구성중인 객체가 의존성 없이 돌아가지 않는다면, 생성자 주입을 사용한다. 만약에 의존성 없이 돌아간다면, 어떤 의존성을 써도 상관 없다.

## 의존성 순환(Circular dependencies)

만약에 두개의 객체가 가까워서 서로에 의존성 주입을 해야한다면, 하나의 객체에서는 프로퍼티 주입이나 메서드 주입을 활용해야한다. 먼저 하나를 만든 다음 생성자 주입을 통해 첫번쨰 객체로 두번째 객체를 만든 다음 첫번째 객체에 프로퍼티를 설정해야한다. 또한 순환사이클을 피하기 위해서 `weak` 이나 `unowned`로 만들어줘야한다.

## 의존성 구현에 대한 대체 (Substituting dependency implementations)

주입으로만 테스트 가능성과 변경 가능성의 장점을 가져가는 것은 어렵다. 여기서는 테스트에서 어떻게 의존성의 행동을 제어할 수 있는지 확인할 수 있다.

의존성 클래스가 디비에서 데이터를 저장하거나 끌어오는 역할을 하고 있다면, 이 디비객체를 뷰컨트롤러에 주입하는것은 디비객체의 행동을 테스트시에 제어할 수 없다. 이러한 이유는 뷰컨트롤러는 디비 의존성의 구현에 의존하고 이 구현은 런타임에 변경될 수 없다. 이 의존성을 제어하기 위해서, 뷰컨트롤러는 다른 디비 구현도 받아들일 수 있어야한다.(가짜 구현 - 내가 제어가능한)

그러므로, 주입 혼자서는 대체 가능성이 불가능하다, 이 대체 가능성을 가능하게 하기 위해서는 의존성을 프로토콜로 정의해서 소비자가 그 의존성 프로토콜을 채택한 다른 클래스들을 주입받을 수 있도록 해야한다. 구성중인 객체를 디자인할때, 의존성을 프로토콜 타입으로 사용해야한다.

의존성 주입을 우리는 컴파일시, 런타임시, 아니면 둘다에 변경할 수 있어야한다. 각각의 의존성은 어디선가 객체화되어있다. 이 의존성 구현을 하기 위해서, 우리는 의존성의 객체화를 If-else로 싸야한다. 특정 조건에서 우리는 가짜 타입을 테스트에 사용하고 다른 조건에서는 앱을 돌리기 위한 진짜 타임을 사용할 수 있어야한다. 

### Compile-time substitution

컴파일시를 제어하기 위해서는 `#if`와 `#elseif`를 사용해야한다.

— 나중에 —

### Runtime substitution

의존성 구현을 런타임에 변경하고 싶을 때가 있다. (베타테스터에게 다른 로직을 보여주고 싶을때)

여러가지 의존성 주입 방법이 있다.

- **On-Demand**: 이 접근에서는, 필요할때 분산 방식으로 의존성 그래프를 생성한다. 하지만 잘 쓰이지 않음
- **Factories**: 초기화 하는 로직을 한 곳에 묶을 수 있다.
- **Single Container**: 이 방식은 초기화 로직을 한 컨테이너에 묶는 것이다. 여기는 상태를 포함하고 있다.
- **Container hierarchy**: 하나로 모든 초기화 로직을 묶는것은 큰 클래스를 만드는 것이다. 여러개의 하나의 컨테이너를 만들고 컨테이너들의 계층을 만들 수 있다.

## On-Demand approach(필요할때 만들기 방식)

DI를 배우고 사소한 상황에 DI를 사용하기 위해서는 최고의 접근방법이다. On-Demand 접근방법에서, 소비자가 새로운 구성죽인 객체가 필요할때마다, 소비자는 소비자가 구성중인 객체를 객체화할 그 시간에 의존성을 생성하거나 찾는다. 다른말로는 소비자가 모든 의존성을 찾는 것에 책임이 있고, 이 의존성을 구성중인 객체에 생성자, 프로퍼티, 메서드를 통해서 제공하도록 만드는 것도 책임을 가진다. 

### Initializing ephemeral dependencies(임시 의존성을 만들기)

만약에 의존성들이 구성중인 객체보다 생애가 짧다면, 구성중인 객체가 가지고 있어도 된다. 그러면 소비자는 그냥 이 의존성을 생성하고, 이 의존성들을 구성중인 객체에 주입하면된다. 이 의존성들을 임시 의존성이라고 한다. 

이러한 경우에는 소비자가 모든 의존성들을 초기화하기 때문에, 이 소비자는 어떤 구현이 의존성이 초기화될때 필요한지 알아야한다. 구성중인 객체는 의존성을 프로토콜 타입으로 사용하기 때문에, 구성중인 객체는 어떤 구체적인 구현이 의존성을 만들때 쓰는지 알수 가 없다.

### Find long-lived dependencies(오래사는 의존성 찾기)

구성중인 객체보다 의존성이 더 오래 산다면, 소비자는 의존성의 참조를 찾을 필요가 있다. 참조는 소비자가 가지고 있을 수도 있다. 그래서 소비자는 애초에 이 의존성에 접근이 가능하다 아니면 소비자의 부모가 가지고 있을 수도 있다.

### 온디멘드 접근의 단점

- 의존성 객체화가 다 산파되어있다. 그리고 같은 초기화 로직 코드가 계속 쓰인다.
- 소비자가 전체 의존성 그래프를 어떻게 그려야하는지 알아야한다. 의존성은 다른 의존성을 가지고 있을 수도 있다. 따라서 소비자가 많은 의존성을 객체화해야할 수 도있다.

## Factories approach (팩토리 접근법)

팩토리접근법은 산파되어있는 것을 하나의 의존성 객체화로 합칠 수 있다.

이 접근법은 임시 의존성에도 적용가능하다. 하지만 이접근법은 싱글톤과 같은 오래사는 의존성을 관리하는데는 어렵다.

팩토리 접근법을 위해서는 팩토리 클래스가 필요하다.

### Factories class

팩토리 클래스는 엄청난 양의 팩토리 메서드로 이루어져있다. 

몇몇 메소드는 의존성을 만들고, 몇몇은 구성중인 객체를 만든다. 그리고 팩토리 객체는 상태를 가지고 있지 않다. 클래스는 저장 프로퍼티를 가지고 있지 않는다.

팩토리 클래스의 목표는 소비자가 구성중인 객체를 어떻게 의존성 그래프를 그리는지 알지 않고도 객체화시킬 수 있도록 하기 위해서이다. 이렇게 하면 객체가 더 작은 객체로 얼마나 많이 분해되는지에 관게 없이 코드의 어느 부분에서나 필요한 객체를 쉽게 확보가능하다.

### Dependency factory methods

의존성 팩토리 메서드는 새로운 의존성 객체를 만드는지에 대한 책임을 가진다.

**creating and getting transitie dependencies**

의존성은 그들만의 의존성을 가지고 있을 수 있기 때문에, 팩토리 메서드는 transitive 의존성을 의존성 객체화 전에 가지고 있을 필요가 있다. 이 Transitive 의존성은 임시적일수도있고, 오래살수도있다.

임시 transitive 의존성을 만들기 위해서는, 의존성 팩토리 메서드는 다른 의존성 팩토리 메서드를 부르면 된다.

장기 transitive 의존성의 참조를 얻기 위해서는, 의존성 팩토리 메서드는 transitive 의존성을 파라미터로 받고 있어야한다. 

**Resolving Protocol dependencies**

의존성 팩토리 메서드는 보통 프로토콜을 리턴타입으로 가진다(대체가능성을 위해). 의존성 팩토리 메서드는 프로토콜과 구현 타입 사이의 매핑을 캡슐화한다.

이것을 resolution이라고 하는데, 왜냐하면 의존성 팩토리 메서드가 특정 프로토콜 의존성에 대해 생성할 구현을 확인하기 때문이다. 즉, 메서드는 어떤 구현 생성자가 쓰일지 알고 있다. → 캡슐화

구체적으로, `UserProfileDataStore` 프로토콜이 있을때, 이 프로토콜은 의존성이다. 팩토리 클래스가 `UserProfileDataStore`가 필요한 구성중인 객체가 `DatabaseUserProfileDataStore`을 사용할 것이라는 로직을 캡슐화한다. 이러한 로직은 하나의 팩토리 메서드에 들어가 있을 것이다. 

이렇게 중앙화를 통해서 `UserProfileDataStore` 의존성을 어떻게 사용되는지 한곳에서만 파악하게 할 수 있다. 이것은 전체 앱에서 변경사항이 있을때, 한곳만 변경하면 된다. 

### 구성중인 객체에서 팩토리 메서드

구성중인 객체에 팩토리 메서드의 책임은 구성중인 객체가 객체화될때 필요한 의존성 그래프를 만드는 일이다. 구성중인 객체 팩토리 메서드는 의존성 팩토리메서드와 동일하게 생겼다. 다른점은 구성중인객체 팩토리 메서드는 팩토리 클래스 밖에서 불리고, 의존성 팩토리 메서드는 팩토리 클래스 안에서 불린다. 

### 런타임에 값을 불러오기

런타임에 정해지는 값이 필요할 경우가 있다. 예를들어서 REST 클라이언트가 행동하기 위해서는 유저 아이디가 필요할 경우가 있다. 이러한 런타임 값들은 보통 **런타임 팩토리 인자**라고 한다. 이것을 다루기 위해서는 파라미터로 구성중인 객체 팩토리 메서드나, 의존성 팩토리 메서드에 넣어주면된다. 

### 의존성 구현 변경하기 (#if, #ifelse)

팩토리 클래스에 대한 대체가능성을 가능하게 할때, 온디멘드에서 썻던 방식 그대로 가면된다. 

### 팩토리 주입하기

만약에 구성중인 객체가 하나의 의존성의 어려개의 객체가 필요하다면? 구성중인 객체가 뷰컨트롤러여서 버튼을 누를때마다 의존성이 만들어져야한다면?

팩토리 메서드는 의존성의 하나의 인스턴스를 빼낸다. 그렇기 때문에, 구성중인 객체가 팩토리메서드를 여러번 부를 수 있는 권한을 줄수가 있다 → 하지만 이것은 유닛테스트가 매우 어렵게 만든다. 왜냐하면 모든 의존성이 밖에서 오는 것이 아니어버리게 되기 때문

이럴 경우, 구성중인 객체가 밖에서부터 의존성들에 여러 객체를 만들 수 있도록 능력을 주어야한다. 우리는 이럴 경우 클로저와 프로토콜을 사용해서 능력을 줄 수 있다.

### 클로저 사용하기

구성중인 객체에 팩토리 클로저 저장 프로퍼티를 추가하는 것이다. 

- 클로저 저장프로퍼티를 구성중인 객체에 하나 만들어준다. `let makeUseCase: () → UseCase`
- 구성중인 객체의 생성자 파라미터에 저렇게 생긴 클로저 타입을 하나 추가해준다.
- 팩토리 클래스에 가서 그 구성중인 객체를 만드는 팩토리 메서드를 찾느다.
- 새로운 의존성을 만들어주는 클로저를 생성자 주입 방법으로 주입한다. 이 클로저 내부에서 해당 의존성에 대한 의존성 팩토리 메서드를 호출하고 새로운 인스턴스를 반환한다. 이 클로저는 팩토리 클래스 객체를 캡처하고 있어서 구성중인 객체는 팩토리 객체를 모른채로 들고 있을 수 있다.
- 이를 통해서 구성중인 객체는 팩토리 클로저를 호출하면서 의존성의 새로운 객체를 만들 수 있다.

구성중인 객체가 팩토리 클로저에서 생성된 종속성 뒤에 있는 모든 transitive dependencies를 알 필요없이 많은 인스턴스를 생성할 수 있기 때문에 개쩐다. 이말은 우리가 전체 의존성 구조를 구성중인 객체의 코드를 하나도 변경할 필요없이 바꿀 수 있다.

### 프로토콜 사용하기

팩토리 프로토콜을 만들어서 구성중인 객체가 팩토리 클래스에게 의존성의 생성을 위임할수 있게 한다. 

- 구성중인 객체가 생성해야할 의존성을 위한 하나의 메소드를 가진 새로운 팩토리 프로토콜을 선언한다.
- 팩토리 클래스는 이미 이 프로토콜을 채택하고 있다. 왜냐하면, 이 프로토콜에 있는 의존성 팩토리 메서드는 팩토리클래스에 있는 구현된 팩토리 메서드와 같아야하기 때문이다. 그냥 단순히 팩토리 클래스에 채택만 시켜주면 된다.
- 팩토리 프로토콜의 저장 프로퍼티와 생성자 파라미터를 구성중인 객체에 추가한다. 이렇게 함으로서 구성중인 객체에  팩토리 객체를 주입할수 있다. 하지만 구성중인 객체는 프로토콜에 정의된 하나의 팩토리 메서드만 볼수 있다. 구성중인 객체는 팩토리 객체가 주입되었다는 것을 모른다, 왜냐하면 프로토콜이 구성중인 객체의 시야를 가렸기 때문이다.
- 팩토리 클래스 내 구성중인 객체의 펙토리 메서드에 가서, 생성자에 `self`를 주입하도록 만든다. `self`는 팩토리 객체로 새로운 팩토리 프로토콜을 채택하고 있다.

구성중인 객체는 새로운 의존성을 팩토리 클래스 내부의 팩토리들에 접근하지 않아도 만들수 있게 되었다. 

### 팩토리 객체 만들기

팩토리 클래스는 상태를 가지고 있지 않는다. 그래서 언제나 팩토리 클래스를 객체화 시켜도 된다. 왜 그냥 static function으로 팩토리 메서드를 만들지 않냐라고 생각할 수 있다. 하지만 container class 에 넣으면서 이생각은 달라질 수 있다. 

### 장점

임시 의존성들이 중앙화된 곳에서 만들어진다. 코드의 간소화

의존성들이 하나의 클래스에서 만들어지니, Test가 쉬어졌다.

소비자들은 변경하는데 더 편해졌다. 왜냐하면 의존성 그래프를 만드는 법을 몰라도 되기 때문이다. 

### 단점

임시적인 객체에서만 사용될 수 있다. 오래사는 객체들은 다른곳에서 관리가 되어야한다. 

## Single-Container approach

컨테이너는 팩토리 클래스와 비슷하지만, 장기 의존성들도 가지고 있을 수 있다. 팩토리클래스의 상태를 가질 수 있는 버전이다.

장기 의존성의 예시로는 데이터 저장소가 그 역할을 다한다. 데이터 저장소 내의 데이터는 변화할수 있고, 우리는 이 데이터의 복사본을 원한다. 그래서 우리는 새로운 데이터저장소 객체를 만들기를 원하지 않는다. 우리는 앱 프로세스 내내 살아있는 하나의 객체를 원한다. 그래서 싱글톤 객체가 필요한 것이다. 데이터 저장소 객체가 계속 살아있게 하려면, ARC가 데이터 자장소를 할당 해제하지 않도록 싱글톤을 유지할 객체가 필요하다. 

### 컨테이너 클래스

컨테이너 클래스는 팩토리 클래스와 비슷하지만, 장기 의존성을 저장하는 저장 프로퍼티를 가지고 있다. 상수 저장 프로퍼티를 컨테이너 생성시에 생성할수도 있고, 아니면 lazy property로 만들어줘도 된다. 하지만 레이지 프로퍼티는 변수여야하므로, 상수가 더 좋다.

### 의존성 팩토리 메서드 in 컨테이너

컨테이너 내부의 의존성 팩토리 메서드에서 임시 transitivie 의존성을 만드는것은 팩토리 클래스에서와 동일하다. 하지만 장기 의존성의 참조를 얻기 위해서, 의존성 팩토리 메소드는 컨테이너의 저장 프로퍼티에서 이를 가져온다. 이렇게 하면 팩토리 메서드의 인자 추가를 안해도 된다.

모든 팩토리 메서드는 어떠한 인풋을 넣지 않더라도 불릴 수 있다. `init(remoteAPI: UserRemoteAPI, dataStore: UserDatastore)`을 `makeProfileViewModel()`로 바꿀 수 있다.

하지만 런타임 값을 예외이다.

### 구성중인 객체 팩토리 메서드 in 컨테이너

구성중인 객체를 생성하는 팩토리 메서드는 저장 프로퍼티를 사용하여 구성중인 객체에 오래사는 의존성을 주입할 수 있다. 

### 장기 의존성 구현을 대체하기

장기 의존성의 구현을 대체하기 위해서 의존성들의 생성자라인을 조건부로 두면 된다. 장기 저장 프로퍼티가 프로토콜 타입을 쓴다면 가능하다. 

### 컨테이너를 만들고 유지하기

팩토리와는 다르게, 컨테이너의 인스턴스는 하나만 만들어야한다. 이유는 컨테이너는 다시 쓰여야하는 의존성들도 역시 가지고 있기 때문이다. 이 말은 앱이 메모리 위에 올라가 있을때, 해제가 되지 않는 객체를 찾아야한다는 것이다. 보통 컨테이너를 앱을 시작핼떄 만든다, 그래서 앱델리게이트에 컨테이너를 넣곤 한다. 

### 장점

- 컨테이너는 앱으리 전체적인 의존성 그래프를 관리한다.
- 싱글톤과 같은 상태를 가진 의존성 객체를 관라할 수 있다. 따라서 싱글톤 참조로 하여금 전역변수로 떠다니지 않게 만들 수 있다.
- 의존성 그래프를 컨테이너 클래스 밖에서 변경하지 않아도 된다.

### 단점

- Massive container class

## 컨테이너 계층 디자인하기

두가지 의존성 객체가 있다. 

1. 임시 객체 - 재사용되지 않음
2. 오래사는 객체 - 앱이 실행되는 동안 계속 살아있음

### 싱글 컨테이너의 문제점을 다시한번 짚어보기

앱의 기능이 많아질수록 컨테이너 클래스는 커질 수 밖에 없다. 이럴 수록 더 많은 팩토리 메서드가 생길 것이. 또한 싱글톤 의존성을 위한 저장 프로퍼티도 많아질 수가 있다. 

또한 많은 옵셔널이 존재할 수 있다. 대부분의 앱에서는 현재 어떤 유저가 로그인 되어있는지 알아야하는 의존성을 가진다. 왜냐하면 유저 ID로 인증을 하기 떄문이다. 

만약에 모든 재사용가능한 의존성이 앱이 살아있을 때 살아있다면, 컨테이너 로직은 많은 옵셔널 경우를 대응해야한다. 왜냐하면 유저는 앱이 실행될때 로그아웃도 할 수 있기 때문이다.

지금까지의 컨테이너 디자인에 따르면 사용자가 로그인을 해야하는 의존성에 대해서 소비자가 컨테이너에 요청하는 것을 막을 수 없다.

이상적으로는 소비자는 이 재사용가능한 의존성에 로그인한 경우에만 접근할수 있다. 하지만 이것은 하나의 의존성컨테이너에 몰래 들어가는 케이스 처리일 뿐이다.

### 객체의 범위

이러한 문제점을 해결하는 방법은 객체의 범위를 디자인하는 것이다. 이렇게 하기 위해서는 의존성들이 언제 만들어지고 언제 죽는지를 생각해봐야한다. user scope에 있는 객체는 user가 로그인을 할때 생겨나고, 유저가 로그아웃하면 죽는다. 뷰컨트롤러 내에 있는 객체들은 뷰컨트롤러가 로드될 때 생겨나고 뷰컨트롤러가 해제될때 죽는다. 

- **App scope** : 전통적인 싱글톤은 App scope으로 생각할 수 있다. 이러한 객체들은 app이 런치될때 생겨나고 앱이 죽을때 죽는다. 일반적으로 이러한 범위를 가진 의존성들은 인증, 분석 트래커, 로그 시스템이 있다.
- **User scope** : 사용자 범위 객체들은 사용자가 로그인을 했을때 생겨나고, 그리고 사용자가 로그아웃하면 사라진다. 몇몇의 앱은 사용자가 여러개의 계정를 가지고 로그인하게 허용한다.(동시로그인) 이러한 경우, 앱은 여러개의 사용자 범위를 동시에 살려야할 수도 있다. 대부분의 의존성들, 서버 API, 데이터 저장소가 이러한 범위를 가진다. 이 범위는 일반적으로 더 상세한 버전의 의존성을 가진다. 예를 들어, 사용자 범위는 사용자 특정 분석 트레커를 가질 수 있고 앱 범위가 익명 분석 트레커를 사용하고 있을 수 있다. 범위는 많은 변경가능한 상태를 변경 불가능한 상태로 만들어줄 수 있다. 이러한 이유로, 수명이 더 짧은 범위를 설계하겨 범위를 더욱 확장할 수 있다.(?)
- **Feature scope** : 기능 범위의 객체들은 사용자가 그 기능으로 넘어왔을때 만들어지고, 그 기능에서 다른 곳으로 넘어갔을때 없어진다. 기능 범위는 기능을 구성하는 많은 객체 간 데이터 공유를 해야할때 편리하다. 예를 들어 쿠버 앱에서, ‘Pick-me-up’ 기능은 사용자의 현재 위치가 필요하다. 사용자의 현재 위치는 한번 불러와지고, 그리고는 다시 검색되지 않는다. 픽업 기능의 관점에서는 현재 위치는 변경할 수 없다. 만흔 다른 뷰 컨트롤러와 비즈니스 로직을 가진 객체를 동작 시키려면 현재 위치를 알아야한다.

기능 범위를 만들면서, 현재 위치를 필요로 하는 모든 객체에게 주입시킬 수 있다.

객체들은 어떻게 객체를 받는지에 대한 걱정을 하지 않아도된다. 사용자가 계속 새로운 차를 필요로 한다고 해도, 새로운 현재 위치가 다시 받아와질 것이지만, 그럼에도 위치 값은 변하지 않는 값이다. 이렇게 되는 이유는 사용자가 새로운 차를 부르면, 새로운 객체 그래프가 다시 만들어질 것이고, 그러면서 변하지 않는 위치 값을 받아올 것이다.

- **Interaction scope** : 상호작용 범위에서의 객체들은 재스처가 불렸을때 만들어지고, 재스쳐가 끝났을때 객체는 없어진다. 복잡한 유저 인터랙션을 만들어야할때, 유용하다.

### 컨테이너 계층화

컨테이너는 의존성의 생애를 관리한다. 그렇기 때문에, 각각의 범위는 컨테이너에 맵핑된다. 사용자 범위는 사용자 범위 컨테이너를 가진다. 사용자 범위 컨테이너는 유저가 로그인을 하면 만들어지는 방향으로 생각하면 된다. 사용자 범위에 있는 의존성들일 어떻게 만들어지고 죽는지 알 수 있다. 왜냐하면 범위 컨테이너가 그 객체들을 가지고 있기 떄문이다. 

모든 범위를 디자인할 때, 컨테이너 클래스를 먼저 만든다. 범위 컨테이너들은 다른 컨테이너들의 팩토리 메서드와 저장 프로퍼티에 접근하고 싶을 수 있다는 것을 인지해야한다. 이렇기 때문에, 컨테이너 계층화를 해야한다.

### 컨테이너 계층화 디자인하기

하나의 간단한 규칙이 컨테이너 계층화하는데 필요하다. 자식 컨테이너는 부모 컨테이너로부터 의존성을 요구해야한다.  부모 컨테이너는 자식 컨테이너에게 의존성을 달라고 요구하지 않는다.

앱 범위 컨테이너는 항상 root container이다. 어떻게 계층이 객체의 생애길이와 맵핑이 되는지 생각해보면, 규칙은 꽤 이해가 된다. 부모 컨테이너는 자식 컨테이너보다 더 오래산다. 만약 부모가 자식에게 의존성을 물어본다면, 아마 자식은 없을 것이다.

결국 컨테이너 계층화는 객체 그래프 그 자체이다. 그러므로, 생성자 주입법을 사용해서 자식 컨테이너에게 의존성을 주입할 수 있다. 

자식 컨테이너 생성자는 부모 컨테이너를 파라미터로 받는다. 자식 컨테이너는 그러면서 부모 컨테이너의 참조를 저장 프로퍼티에 저장한다. 이렇게 하면서 자식 컨테이너는 부모 컨테이너의 모든 팩토리 메서드와 저장 프로퍼티에 접근할 수 있다.

예를 들어, `UserProfileViewModel`에서 로그 이벤트를 찍어보기 위해 `Logger` 가 필요하다. `Logger`는 앱이 살아있을때 계속 살아있어야한다. 왜냐하면 유저가 로그인을 했건 하지 않았건 로그를 찍어볼 수 있어야하기 때문이다. 따라서 `Logger` 는 `AppDependencyContainer`에 있다.

해결하기 위해서 `AddDependencyContainer` 파라미터가 `UserDependencyContainer`의 생성자에 필요하다. 이러한 방법으로, `UserDependencyContainer`는 `AppDependencyContainer`에게 로거를 `UserProfileViewModel`을 생성할때 요구할 수 있다.

### 데이터 캡쳐링

의존성의 생애주기를 관라히는 데 더불어, 컨테이너는 데이터 모델 값들을 캡쳐할 수 있다. 이 방법은 만약에 데이터 모델 값이 불변하는 값이라면 유용하다. 컨테이너에 데이터를 캡쳐한다면, 결국 변화하는 값들을 불변값으로 변경하는 방법이다. (?) 이것은 결국 컨테이너 내부의 코드를 더 확실하게 바꿔준다. 왜냐하면 로직이 안바뀌니깐!

AppContainer라는 앱 범위 컨테이너가 있을때, AppContainer는 유저의 세션값을 가진 UserSessionDataStore를 가진다.  유저 범위 컨테이너라는 UserContainer가 있을때, UserContainer는 현재 로그인한 사용자 세션 객체로 AppContainer와 함께 초기화된다. 데이터 저장소가 아니라 실제 세션이다. 

중요한 이유는 user container는 사용자 세션 없이는 존재할 수 없다. 이 방법은 로그인한 사용자와 관련된  옵셔널 케이스 핸들링을 없애준다.

`UserContainer` 내부에 `UserProfileRemoteAPI`를 생성하기 위한 팩토리 메서드가 있다고 가정할때, `RemoteAPI`를 작동하려면 사용자 세션이 필요하다. `RemoteAPI` 팩토리 메서드는 사용자 세션 저장 속성에 액세스 할 수 있다. 왜냐하면 팩토리와 저장 프로퍼티는 모두 같은 `UserContainer` 클래스 에 있다.  → 사용자가 로그인 했는지 안했는지에 대한 코드는 사라진다.

### 장점

- 범위화는 싱글톤을 할 필요 없는 의존성들을 디자인할 수 있다.
- 값을 캡쳐하면서, 변화하는 값을 불변값으로 만들 수 있다 (?)

## DI 이론을 앱에 적용하기

### 객체 그래프와 iOS 앱

UIApplication 객체는 앱 객체 그래프의 root이다. UIApplicationDelegate은 UIApplication의 자식이다. 앱 델리게이트가 iOS 앱의 첫 들어가는 포인트이기 때문에, 앱델리게이트는 DI를 만드는 곳이라고 할 수 있다. 

다음으로 할 것은 아마, root viewcontroller를 만드는 일이다. 루트 뷰컨트롤러는 객체 그래프의 루트에 있다 어떻게 DI 컨테이너를 사용할 것인가! 이것이 목표이다.

### Koober 앱의 인증 객체 그래프 살펴보기

### UserSessionRepository’s Dependency graph

여기에 `KooberUserSessionRepository`를 만들기 위한 프로토콜과 객체가 있다.

- AuthRemoteAPI: `AuthRemoteAPI` 프로토콜은 쿠버의 인증 시스템의 네트워크 레이어를 대표한다. 이 프로토콜의 구현은 쿠버 클라우드 서비스에 로그인과 회원가입을 요창하는 것일 것이다. 성공적인 리스폰스로 쿠버 클라우드는 토큰을 보내줄 것이다.
- UserSessionCoding : `UserSessionCoding` 프로토콜을 구현한 객체는 `UserSession` 객체를 `Data`로 인코딩해준다. 또한 `Data`를 `UserSession`으로 디코딩해준다. 쿠버의 `KeychainUserSessionDataStore`은 이 프로토콜을 `UserSession`을 `Data`로 키체인에 저장하기 위해 사용한다.
- UserSessionDataStore: `UserSessionDataStore`의 구현은 유저 세션를 로그인한 사용자를 위해서 저장하는 것이다. 쿠버는 이 프로토콜의 많은 다른 구현체를 가진다. 예를 들어서 `FileUserSessionDataStore`을 개발중에 앱을 시뮬레이터에서 지웠을때, 현재 유저를 로그아웃하도록 사용할 수 있다. `KeyChainUserSessionDataStore`은 진짜 사용자의 기밀을 키체인에 저장할 수 있도록 만들어두었고, 앱 스토어에 올릴때 쓴다. `KeyChainUserSessionDataStore`은 `UserSessionCoding`을 채택하는 유저 세선 코더에 의존한다.
- UserSessionRepository: 이 리포지토리는 CRUD 프로토콜로 유저 세션을 관리한다. 쿠버가 런칭할때, 사용자가 로그인되어있는지 안되어있는지 확인하는데 사용된다. `KooberUserSessionRepository` 가 이 프로토콜을 구현하고 쿠버에서 사용되는 기본 구현이다. `KooberUserSessionRepository`는 상태를 가지고 있으며, 이 객체는 앱이 살아있을때, 내내 살아있어야한다.

KooberUserSessionRepository의 의존성 그래프

<img width="392" alt="스크린샷_2022-01-25_오후_3 14 39" src="https://user-images.githubusercontent.com/69891604/151143310-00c00fe8-7680-404c-b694-ea13b87fc37d.png">

(구현타입이 프로토콜 타입에 의존하는 것 확인)

`KooberUserSessionRepository`의 의존성 그래프는 `UserSessionDataStore`가 해결된다면 이렇게될 것입니다 (아래)

<img width="549" alt="스크린샷_2022-01-25_오후_3 18 19" src="https://user-images.githubusercontent.com/69891604/151143341-0f1b63aa-91d9-4941-a5b7-ebddea4ad807.png">

마지막으로는 KooberUserSessionRepository의 완성된 의존성 그래프는 :

<img width="515" alt="스크린샷_2022-01-25_오후_3 19 14" src="https://user-images.githubusercontent.com/69891604/151143381-739378d4-e9b3-41e0-8fee-9f49cc1e9a01.png">


### LauchViewController의 의존성 그래프

`LaunchViewController`를 위한 프로토콜과 객체들

- NotSignedInResponder: `NotSignedInResponder`은 사용자 인증 프로토콜이다. 쿠버 내의 객체들은 유저가 로그인을 안되어있는지를 파악하기 위해 이 프로토콜을 부른다. 이것은 런치할때 혹은 로그아웃을 할때 발생한다. 이 프로토콜을 구현하는 객체는 사용자를 `OnboardingViewController`로 이동하게 하고 `MainViewModel`은 이 프로토콜을 구현한다.
- SignInResponder: `SignedInResponder`은 또한 사용자 인증 프로토콜이다. 이 프로토콜도 유저가 로그인되어있는지를 결정하기위해 쓰인다. 이 프로토콜은 시작할때, 로그인 후, 회원가입 후 에 실행될 수 있다. `MainViewModel`이 구현한다.
- LaunchViewModel: 이 뷰모델은 `LauchViewController`의 UI 상태를 가지고 있다. 이 객체는 보통 장기 의존성이다. 하지만 쿠버에서는 앱이 프로세스 생애주기일떄 한번만 실행되므로 `LaunchViewController`가 하나만 생성된다. 결국은 이 의존성은 임시적이다.
- LaunchViewController: 쿠버가 처음 실행될때, `LaunchViewController`는 로그인한 사용자를 찾고 스플래쉬 스크린을 띄운다. `LaunchViewController`는 로그인한 유저를 찾기 위해서 `LaunchViewModel`에 의존한다.
    
<img width="535" alt="스크린샷_2022-01-25_오후_3 45 10" src="https://user-images.githubusercontent.com/69891604/151143411-ebf03e2e-ead3-48fd-a6e0-a8b896865d2c.png">

<img width="531" alt="스크린샷_2022-01-25_오후_3 56 08" src="https://user-images.githubusercontent.com/69891604/151143456-b3f634f9-6f17-4aa3-8c41-fd592b8dae9f.png">
    
### OnboardingViewController의 의존성 그래프

- OnboardingViewModel: `OnboardingViewController`의 상태를 가지고 있다. 이 객체는 사용자가 로그아웃할때 오래사는 의존성이다.
- GoToSignUpNavigator: `GoToSignUpNavigator`은 UI 네비게이션 프로토콜이다. 구현체는 Sign-up 화면으로 전환해주는 일이다. `OnboardingViewModel`이 이 프로토콜을 구현한다.
- GoToSignInNavigator:  구현체는 sign-in 화면으로 전환하는 책임을 가진다. `OnboardingViewModel`이 이 프로토콜을 구현한다.
- WelcomeViewModel: 이 뷰모델은 `WelcomeViewController`의 상태를 가진다.
- WelcomeViewController: welcomescreen을 보여주고, signup화면 혹은 Signin 화면으로 가게한다.
- SignInViewModel
- SignInViewController
- SignUpViewModel
- SignUpViewController
- OnboardingViewController: 만약에 사용자가 로그인을 안해쓰면 MainViewController는 OnboardingViewController를 보여줄 것이다. OnboardingViewController는 컨테이너 뷰컨트롤러로 welcome, signin,signup 중 어디로 보낼 수 있다. 이 컨트롤러는 유저가 로그인을 안하는 동안에만 활성상태여야한다.
    
<img width="531" alt="스크린샷_2022-01-25_오후_4 11 44" src="https://user-images.githubusercontent.com/69891604/151143518-53bfabce-1ec5-47d7-9cf1-f42647a6fb5b.png">

    
<img width="511" alt="스크린샷_2022-01-25_오후_4 12 14" src="https://user-images.githubusercontent.com/69891604/151143541-4bde0f1f-27c0-47ba-bfed-23ee18b0f345.png">

    
### MainViewController의 의존성 그래프

- MainViewModel : MainViewModel은 MainViewController의 UI 상태를 가지고 있다. 객체는 상태를 가지고 있다. 그래서 길게사는 의존성이다.
- MainViewController : MainViewController은 쿠버의 루트뷰컨트롤러이다. MainViewController은 컨테이너 뷰컨트롤러로 상단의 네비게이션 관리를한다. MainViewController은 런치스크린, 로그인 스크린, 회원가입스크린 의 present와 dismiss를 담당한다. MainViewController 뷰컨트롤러 팩토리메서드에 의존한다.
    
<img width="573" alt="스크린샷_2022-01-25_오후_4 22 16" src="https://user-images.githubusercontent.com/69891604/151143587-004d20b9-28a3-4e0e-a375-ceae2fa0b532.png">
    

## 온디멘드 접근 적용하기

[온디멘드 접근법 적용하기(잘안쓰임)](https://github.com/pastapeter/iOS-BUG-FIX-STUDY/blob/master/%EC%9D%98%EC%A1%B4%EC%84%B1%20%EC%A3%BC%EC%9E%85/%EC%98%A8%EB%94%94%EB%A9%98%EB%93%9C%20%EC%A0%91%EA%B7%BC%EB%B2%95%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0(%EC%9E%98%EC%95%88%EC%93%B0%EC%9E%84).md)

## 팩토리 접근법 적용하기

[팩토리 접근법 적용하기](https://github.com/pastapeter/iOS-BUG-FIX-STUDY/blob/master/%EC%9D%98%EC%A1%B4%EC%84%B1%20%EC%A3%BC%EC%9E%85/%ED%8C%A9%ED%86%A0%EB%A6%AC%20%EC%A0%91%EA%B7%BC%EB%B2%95%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0.md)

## 싱글 컨테이너 접근법 적용하기

[싱글컨테이너 접근법](https://github.com/pastapeter/iOS-BUG-FIX-STUDY/blob/master/%EC%9D%98%EC%A1%B4%EC%84%B1%20%EC%A3%BC%EC%9E%85/%EC%8B%B1%EA%B8%80%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%20%EC%A0%91%EA%B7%BC%EB%B2%95.md)

## 컨테이너 계층 접근법 적용하기

[컨테이너 계층 접근법 적용하기](https://github.com/pastapeter/iOS-BUG-FIX-STUDY/blob/master/%EC%9D%98%EC%A1%B4%EC%84%B1%20%EC%A3%BC%EC%9E%85/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%20%EA%B3%84%EC%B8%B5%20%EC%A0%91%EA%B7%BC%EB%B2%95%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0.md)

## 키포인트

- 소비자는 구성중인 객체가 필요하다. 구성중인 객체는 transitive 의존성들이 필요하다. 이 객체들은 객체 그래프를 만든다.
- 의존성에 접근성, 대체가능성 정하기, 대체가능성 디자인하기가 객체의존성을 관리하는 데의 장점에 대한 가장 기본적인 물음에 대한 해답이다.
- Dependency Injection, Service Locator, Environment, Protocol Extensions이 iOS에서 주로 쓰이는 의존성 패턴이다.
- 구성중인 객체가 의존성의 여러개 객체를 만들 필요가 있다면, factory Closure 혹은 factory protocol을 만들어주면 된다.
